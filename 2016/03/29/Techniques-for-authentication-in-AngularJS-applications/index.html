<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【译】AngularJS身份验证技巧 · 小镇</title><meta name="description" content="【译】AngularJS身份验证技巧 - 小振 Manji.z"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"><script src="http://tajs.qq.com/stats?sId=54492646" charset="UTF-8"></script></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2289478794" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Manjiz" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">【译】AngularJS身份验证技巧</h1><div class="post-info"><span class="post-time">Mar 29, 2016</span><span class="post-author">右小镇</span></div><div class="post-content"><p>原文：<a href="https://medium.com/opinionated-angularjs/techniques-for-authentication-in-angularjs-applications-7bbf0346acec#.a025w449d" target="_blank" rel="external">https://medium.com/opinionated-angularjs/techniques-for-authentication-in-angularjs-applications-7bbf0346acec#.a025w449d</a></p>
<p>前言：笔者在用Angular做一个需求平台应用的时候，就遇上了这个令人苦恼的问题——它几乎所有的页面都对应着同一个路由，所以不能在服务器端作权限控制，所以只能在客户端侧进行控制，往往又要让客户端知道连接有没有断开，权限有没有变更，这些变动都不会即时在客户端侧生效。多得这篇文章为我解惑，在此抛砖引玉，内文在保持原文内容的前提下带有本人粗疏见解。</p>
<h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>最常见的身份验证就是通过用户名（或邮箱）和密码进行登录，也就意味着要创建一个能填入验证信息的表单，大概是这样子的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">name</span>=<span class="value">"loginForm"</span> <span class="attribute">ng-controller</span>=<span class="value">"LoginController"</span> <span class="attribute">ng-submit</span>=<span class="value">"login(credentials)"</span>  <span class="attribute">novalidate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"username"</span>&gt;</span>Username: <span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"username"</span> <span class="attribute">ng-model</span>=<span class="value">"credentials.username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"password"</span>&gt;</span>Password: <span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"password"</span> <span class="attribute">ng-model</span>=<span class="value">"credentials.password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">type</span>=<span class="value">"submit"</span>&gt;</span>Login<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是一个Angular表单，在提交的时候执行登录函数。需要注意的是，我们把 <code>credentials</code> 当作一个参数传过去，而不是在函数中通过 <code>$scope.credentials</code> 来引用，这样做对单元测试非常有用，而且可以降低登录函数与它所在scope的耦合，controller的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.controller(<span class="string">'LoginController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, $rootScope, AUTH_EVENTS, AuthService</span>) </span>&#123;</span><br><span class="line">    $scope.credentials = &#123;usernameL:<span class="string">''</span>, password:<span class="string">''</span>&#125;;</span><br><span class="line">    $scope.login = <span class="function"><span class="keyword">function</span>(<span class="params">credentials</span>) </span>&#123;</span><br><span class="line">        AuthService.login(credentials).then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">            $rootScope.$broadcast(AUTH_EVENTS.loginSuccess);</span><br><span class="line">            $scope.setCurrentUser(user);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            $rootScope.$broadcast(AUTH_EVENTS.loginFailed);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这段代码缺少了部分逻辑，因为我们已经把这些逻辑从controller中抽取出来放到services了，controller应该只管$scope对象（通过watching或者manipulating），而不是负责过多的工作。</p>
<h2 id="通知session变化"><a href="#通知session变化" class="headerlink" title="通知session变化"></a>通知session变化</h2><p>身份验证会影响到整个应用的所有state，所以我会用events（通过$broadcast发送）来通知用户session的改变。把所有可能的事件定义在首要的位置是个不错的选择，我选择constants来做这些事：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.constant(<span class="string">'AUTH_EVENTS'</span>, &#123;</span><br><span class="line">    loginSuccess: <span class="string">'loginSuccess'</span>,</span><br><span class="line">    loginFailed: <span class="string">'loginFailed'</span>,</span><br><span class="line">    logoutSuccess: <span class="string">'logoutSuccess'</span>,</span><br><span class="line">    sessionTimeout: <span class="string">'sessionTimeout'</span>,</span><br><span class="line">    notAuthenticated: <span class="string">'notAuthenticated'</span>,</span><br><span class="line">    notAuthorized: <span class="string">'notAuthorized'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>用constants的好处是他们能像services一样被引入，这样有利于在单元测试中模拟数据。而且，可以让你轻松修改他们的值，而不用修改一大堆的文件。同样，用户角色也类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.constant(<span class="string">'USER_ROLES'</span>, &#123;</span><br><span class="line">    all: <span class="string">'*'</span>,</span><br><span class="line">    admin: <span class="string">'admin'</span>,</span><br><span class="line">    editor: <span class="string">'editor'</span>,</span><br><span class="line">    guest: <span class="string">'guest'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果你想要让editor有管理员的权限，可以把它的值改成admin即可。</p>
<h2 id="The-AuthService"><a href="#The-AuthService" class="headerlink" title="The AuthService"></a>The AuthService</h2><p>身份验证和权限控制最好放在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.factory(<span class="string">'AuthService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$http, Session</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> authService = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    authService.login = <span class="function"><span class="keyword">function</span>(<span class="params">credentials</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $http.post(<span class="string">'/login'</span>, credentials).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            Session.create(res.data.id, res.data.user.id, res.data.user.role);</span><br><span class="line">            <span class="keyword">return</span> res.data.user; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    authService.isAuthenticated = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !!Session.userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    authService.isAuthorized = <span class="function"><span class="keyword">function</span>(<span class="params">authorizedRoles</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!angular.isArray(authorizedRoles)) &#123;</span><br><span class="line">            authorizedRoles = [authorizedRoles];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (authService.isAuthenticated() &amp;&amp; authorizedRoles.indexOf(Session.userRole) !== -<span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> authService;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>为了进一步拆分身份验证的逻辑，我用另外一个service（一个 <a href="https://gist.github.com/Mithrandir0x/3639232" target="_blank" rel="external">service style</a> 的单例对象）来保存用户的信息，它依赖于你的后端实现，但我这里只给出一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.service(<span class="string">'Session'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">sessionId, userId, userRole</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = sessionId;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.userRole = userRole;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.destroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.userId = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.userRole = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>用户登录后，他的信息应该要展示在什么地方（比如右上角），用户object应该能被$scope甚至整个应用引用到，虽然$rootScope是个很好的选择，但我尽量避免过多地使用$rootScope（事实上我只在全局事件的广播中使用它）。我倾向于在应用的根节点（至少是节点树中较高的位置）定义controller，body标签就是个很好的选择：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-controller</span>=<span class="value">"ApplicationController"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ApplicationController是一个包含很多全局逻辑的容器，也是run方法的替代，它处于$scope树的顶部，所有其他的scope都继承自它（除了被隔离的scope）。在这里定义currentUser是个很好的选择：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.controller(<span class="string">'ApplicationController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, USER_ROLES, AuthService</span>)</span>&#123;</span><br><span class="line">    $scope.currentUser = <span class="literal">null</span>;</span><br><span class="line">    $scope.userRoles = USER_ROLES;</span><br><span class="line">    $scope.isAuthorized = AuthService.isAuthorized;</span><br><span class="line">    $scope.setCurrentUser = <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">        $scope.currentUser = user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>事实上我们没有给currentUser赋值，我们只是初始化这个变量，以便应用能够访问得到它。不幸地，我们不能简单地在child scope给它赋值，因为原始类型（strings, numbers, booleans, undefined 和 null）是值传递而不是引用传递，这样做会产生一个shadow property。为了规避这个问题，我们设置了一个setter方法。了解更多Angular scope和原型继承，阅读 <a href="https://github.com/angular/angular.js/wiki/Understanding-Scopes" target="_blank" rel="external">Understanding Scopes</a>。</p>
<p>除了初始化currentUser，我们还有几个快速访问USER_ROLES的变量和isAuthorized方法。他们都应该只用在模版表达式中，而不是给其他的controller使用的，不然会降低controller的可测性。</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>其实，身份验证也就是访问控制在AngularJS中并不存在，客户端应用的所有源码都在用户的手上，我们无法阻止用户篡改代码来访问到部分页面和内容，我们所能做的只是显示控制，如果你需要真正意义上的身份验证，你只能在服务器端做，但已经超出本文的范畴了。</p>
<h3 id="限制元素显示"><a href="#限制元素显示" class="headerlink" title="限制元素显示"></a>限制元素显示</h3><p>AngularJS可以有好多种指令来显示隐藏元素：ngShow, ngHide, ngIf和ngSwitch。前两种通过style来操纵显隐，后两种会直接移除元素。</p>
<p>第一种方案最好用在表达式会经常变化和元素不包含很多模版逻辑或引用的情况，因为任何在已隐藏元素下的模版逻辑仍然会被digest循环检查一遍，这会降低应用性能。第二种方案会移除整个元素（包括事件处理器和域绑定），对浏览器来说，改变DOM元素需要做很多的工作（这也是使用第一种方案的一个原因），但更多的时候是值得的，比如用在不会经常切换可见性的元素上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-if</span>=<span class="value">"currentUser"</span>&gt;</span>Welcome, &#123;&#123;currentUser.name&#125;&#125;<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-if</span>=<span class="value">"isAuthorized(userRoles.admin"</span>&gt;</span>Your're admin.<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-switch</span> <span class="attribute">on</span>=<span class="value">"currentUser.role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-switch-when</span>=<span class="value">"userRoles.admin"</span>&gt;</span>Your're admin.<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-switch-when</span>=<span class="value">"userRoles.editor"</span>&gt;</span>Your're editor.<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-switch-default</span>&gt;</span>Your're something else.<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子是以用户只有一种身份为前提的，你可以把它改得更灵活。</p>
<h3 id="限制路由访问"><a href="#限制路由访问" class="headerlink" title="限制路由访问"></a>限制路由访问</h3><p>大多时候你想要阻止访问整个页面而不是一两个元素，这时可以在route用自定义的数据对象（或UI Router的state），我们能规定哪些角色能访问到，例子是 <a href="https://github.com/angular-ui/ui-router" target="_blank" rel="external">UI Router</a> 的形式，对ngRoute也有效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.config(<span class="function"><span class="keyword">function</span>(<span class="params">$stateProvider, USER_ROLES</span>) </span>&#123;</span><br><span class="line">    $stateProvider.state(<span class="string">'dashboard'</span>, &#123;</span><br><span class="line">        url: <span class="string">'/dashboard'</span>,</span><br><span class="line">        templateUrl: <span class="string">'dashboard/index.html'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            authorizedRoles: [USER_ROLES.admin, USER_ROLES.editor]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来，我们会在每次路由改变的时候检查这个值，这通过监听ngRoute的$routeChangeStart或UI Router的$stateChangeStart来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.run(<span class="function"><span class="keyword">function</span> (<span class="params">$rootScope, AUTH_EVENTS, AuthService</span>) </span>&#123;</span><br><span class="line">    $rootScope.$on(<span class="string">'$stateChangeStart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> authorizedRoles = next.data.authorizedRoles;</span><br><span class="line">        <span class="keyword">if</span> (!AuthService.isAuthorized(authorizedRoles)) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">            <span class="keyword">if</span> (AuthService.isAuthenticated()) &#123;</span><br><span class="line">                <span class="comment">// 用户没有访问这个页面的权限</span></span><br><span class="line">                $rootScope.$broadcast(AUTH_EVENTS.notAuthorized);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 用户没有登录</span></span><br><span class="line">                $rootScope.$broadcast(AUTH_EVENTS.notAuthenticated);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当用户因为没有登录或者没有访问权时，阻止用户访问并停留在当前页面，然后广播一个事件给其他模块。我建议在每一个页面加一个登录框，当接收到用户没登录的广播事件时就弹出来，还有在接收到用户无权限访问事件时提示错误信息。</p>
<h2 id="Session-时效"><a href="#Session-时效" class="headerlink" title="Session 时效"></a>Session 时效</h2><p>身份验证本来就是服务器端的事情，无论你怎么实现，你的后端一定是事实上验证用户信息和处理session时效以及访问控制的部分，这意味着你的API有时要返回身份验证错误，标准的方法是使用HTTP状态码，通常是以下这些：</p>
<ul>
<li>401 Unauthorized - 用户没登录</li>
<li>403 Forbidden - 用户没访问权限</li>
<li>419 Authentication Timeout (non standard) - Session过期</li>
<li>440 Login Timeout (Microsoft only) - Session过期</li>
</ul>
<p>最后两个不是标准但已经被广泛使用，用401来通知session过期是最正确的选择，你的登录框应该在返回401、419或者440的时候弹出来，在返回403的时候则提示错误信息，为了在返回这些状态码的时候广播“未登录”或“无权限”事件，我们给$httpProvider增加一个拦截器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.config(<span class="function"><span class="keyword">function</span> (<span class="params">$httpProvider</span>) </span>&#123;</span><br><span class="line">    $httpProvider.interceptors.push([</span><br><span class="line">        <span class="string">'$injector'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$injector</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $injector.get(<span class="string">'AuthInterceptor'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ]);</span><br><span class="line">&#125;)</span><br><span class="line">.factory(<span class="string">'AuthInterceptor'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$rootScope, $q, AUTH_EVENTS</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        responseError: <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123; </span><br><span class="line">            $rootScope.$broadcast(&#123;</span><br><span class="line">                <span class="number">401</span>: AUTH_EVENTS.notAuthenticated,</span><br><span class="line">                <span class="number">403</span>: AUTH_EVENTS.notAuthorized,</span><br><span class="line">                <span class="number">419</span>: AUTH_EVENTS.sessionTimeout,</span><br><span class="line">                <span class="number">440</span>: AUTH_EVENTS.sessionTimeout</span><br><span class="line">            &#125;[response.status], response);</span><br><span class="line">            <span class="keyword">return</span> $q.reject(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这只是一个简单的认证拦截器实现，有个非常棒的 <a href="https://github.com/witoldsz/angular-http-auth" target="_blank" rel="external">Github项目</a> 做了同样的事情，并且使用了httpBuffer服务（在出现HTTP错误时阻止进一步API请求直到用户重新登录，然后按顺序继续完成这些请求）。 </p>
<h3 id="登录框指令"><a href="#登录框指令" class="headerlink" title="登录框指令"></a>登录框指令</h3><p>当session过期了，我们需要用户重新输入他的认证信息，为了防止用户丢失正在进行的事情，最好用一个登录弹框来替代跳转到登录页。这个登录框应该监听notAuthenticated和sessionTimeout事件，接收到这些事件它会自己弹出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.directive(<span class="string">'loginDialog'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">AUTH_EVENTS</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        restrict: <span class="string">'A'</span>,</span><br><span class="line">        template: <span class="string">'&lt;div ng-if="visible" ng-include="\'login-form.html\'"&gt;'</span>,</span><br><span class="line">        link: <span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> showDialog = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                scope.visible = <span class="literal">true</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            scope.visible = <span class="literal">false</span>;</span><br><span class="line">            scope.$on(AUTH_EVENTS.notAuthenticated, showDialog);</span><br><span class="line">            scope.$on(AUTH_EVENTS.sessionTimeout, showDialog)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当然你也可以按你的意思去修改，主要在于登录表单模板和它的LoginController的复用，你需要在每一个页面（除了登录页）中增加下面这东西：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">login-dialog</span> <span class="attribute">ng-if</span>=<span class="value">"!isLoginPage"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意检查 <code>isLoginPage</code> ，我们并不想一个登录弹框出现在登录页中，然后可以在ApplicationController中定义 <code>$scope.isLoginPage</code>。</p>
<h2 id="登录表单的问题"><a href="#登录表单的问题" class="headerlink" title="登录表单的问题"></a>登录表单的问题</h2><p>许多用户会依赖于密码管理器来保存登录信息，以便下次登录，如果你用的是本文开头那样子的表单，会有两个问题：</p>
<ul>
<li>表单的提交不会被检测到（浏览器也就不会提示你去保存登录信息）</li>
<li>自动填充的字段不会被Angular获取到</li>
</ul>
<p>想要规避这些问题，就要引入iframe和一个timeout函数。如果你想让你的代码保持清洁，你应该把登录表单完全放到AngularJS之外，通过传统的服务器端渲染。否则，这里有一个“改进”的表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">iframe</span> <span class="attribute">src</span>=<span class="value">"sink.html"</span> <span class="attribute">name</span>=<span class="value">"sink"</span> <span class="attribute">style</span>=<span class="value">"display:none"</span>&gt;</span><span class="tag">&lt;/<span class="title">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">name</span>=<span class="value">"loginForm"</span></span><br><span class="line">        <span class="attribute">action</span>=<span class="value">"sink.html"</span> <span class="attribute">target</span>=<span class="value">"sink"</span> <span class="attribute">method</span>=<span class="value">"post"</span></span><br><span class="line">        <span class="attribute">ng-controller</span>=<span class="value">"LoginController"</span></span><br><span class="line">        <span class="attribute">ng-submit</span>=<span class="value">"login(credentials)"</span></span><br><span class="line">        <span class="attribute">novalidate</span> <span class="attribute">form-autofill-fix</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"username"</span>&gt;</span>Username:<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"username"</span> <span class="attribute">ng-model</span>=<span class="value">"credentials.username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"password"</span>&gt;</span>Password:<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"password"</span> <span class="attribute">id</span>=<span class="value">"password"</span> <span class="attribute">ng-model</span>=<span class="value">"credentials.password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">type</span>=<span class="value">"submit"</span>&gt;</span>Login<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不同之处在于，新增加的iframe和form上增加的几个属性（action, target和method），表单会在触发ngSubmit的同时提交到iframe中的sink.html，这样就不用跳转到sink.html而触发浏览器对表单的正常处理逻辑，密码管理器会当作一个普通的表单提交一样询问你是否保存登录信息。sink.html只是一个空的html文件，你最好给这个文件一个备注好让其他的开发者不会感到困惑这个文件是干嘛用的。</p>
<blockquote>
<p>不要忘了 <code>method=&quot;post&quot;</code> ，否则登录信息会被串成参数字符串保存在浏览历史中。</p>
</blockquote>
<p>现在密码管理器能保存你的登录信息了，我们还要让他们自动回填，问题是有些浏览器在自动填充的时候不会触发事件，也就是说AngularJS不知道这个字段已经改变了，$scope中的值也就不会改变，这就导致了你看着有东西，提交过去却是空的，然后就有了这个 <a href="http://victorblog.com/2014/01/12/fixing-autocomplete-autofill-on-angularjs-form-submit/" target="_blank" rel="external">formAutofillFix</a> 指令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.directive(<span class="string">'formAutofillFix'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$timeout</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs</span>) </span>&#123;</span><br><span class="line">        element.prop(<span class="string">'method'</span>, <span class="string">'post'</span>);</span><br><span class="line">        <span class="keyword">if</span> (attrs.ngSubmit) &#123;</span><br><span class="line">            $timeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                element</span><br><span class="line">                    .unbind(<span class="string">'submit'</span>)</span><br><span class="line">                    .bind(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">                        event.preventDefault();</span><br><span class="line">                        element</span><br><span class="line">                            .find(<span class="string">'input, textarea, select'</span>)</span><br><span class="line">                            .trigger(<span class="string">'input'</span>)</span><br><span class="line">                            .trigger(<span class="string">'change'</span>)</span><br><span class="line">                            .trigger(<span class="string">'keydown'</span>);</span><br><span class="line">                        scope.$apply(attrs.ngSubmit);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个指令器会重新绑定一个submit事件，这个事件会触发每个输入元素的几个事件（以此让Angular更新scope），等Angular完成digest的循环后执行ngSubmit的函数，表单提交的时候，scope中所有的值都更新了一遍。这个方法的缺点是，表单的格式验证不会正常工作，因为自动填充的值在提交前不能被获取到，这里有一个 <a href="https://github.com/tbosch/autofill-event" target="_blank" rel="external">plyfill</a> 能让change事件更早地触发。</p>
<h2 id="恢复用户状态"><a href="#恢复用户状态" class="headerlink" title="恢复用户状态"></a>恢复用户状态</h2><p>对于单页应用（SPA）来说，在用户刷新页面的时候保持和恢复登录信息是个非常难办的事情，因为现在所有的状态都保存在了客户端，刷新会清空用户的信息，为此，我通常会实现一个返回用户数据的（如果有登录的话）的API路径（比如 /profile），在AngularJS应用启动的时候（比如run中）请求这个路径，返回来的信息保存在Session service或$rootScope中，这个过程就像登录一样。或者，可以把用户数据嵌在index.html，这样你就不用额外的请求了。第三种解决方案是把用户数据保存在cookie或者Local Storage中，但这会让注销或者清空用户数据变得困难一些。</p>
<p>当通过URL直接访问一个需要登录的页面时，可能会发生这种情况——用户数据还没加载完，这个页面就渲染出来了。这可以通过在路由中定义resolve来解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$stateProvider.state(<span class="string">'protected-route'</span>, &#123;</span><br><span class="line">    url: <span class="string">'/protected'</span>,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        auth: <span class="function"><span class="keyword">function</span> <span class="title">resolveAuthentication</span>(<span class="params">AuthResolver</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> AuthResolver.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面这个AuthResolver是一个监控currentUser的service，它只会在currentUser设置之后才继续执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.factory(<span class="string">'AuthResolver'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$q, $rootScope, $state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        resolve: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> deferred = $q.defer();</span><br><span class="line">            <span class="keyword">var</span> unwatch = $rootScope.$watch(<span class="string">'currentUser'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">currentUser</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (angular.isDefined(currentUser)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">                        deferred.resolve(currentUser);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        deferred.reject();</span><br><span class="line">                        $state.go(<span class="string">'user-login'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    unwatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> deferred.promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>因为这个监听器只会被用到一次，所以用过后就该停掉它。你可以修改上面这个例子，比如登录后跳转到原来所要访问的页面。</p>
<p>当然，还有无数的其他方法供你探索。记住，真正的安全在服务器端而不是客户端，还有就是记得用HTTPS。</p>
<hr>
<p>笔者抛几个问题：</p>
<ul>
<li><p>在 <strong>恢复用户状态</strong> 中，我们只能给每个state都加上同一个resolve，但没找到一个很好的办法使得只定义一次，每次切换state之前（尤其是通过URL直接访问时）都能触发。</p>
<p>笔者的处理方式是：用一个变量来标志用户的数据是否已经通过API获取更新过了，在state切换的时候，如果标志为false，则通过 <code>$state.go(&#39;xxx&#39;)</code> 不断地跳转，直到API有响应返回用户数据了，其中xxx就是要跳转到的state，这样的问题是，如果API一直没有响应，那岂不是个死循环。</p>
</li>
<li><p>在每个页面都加上登录弹框明显是一件重复性的工作，是否可以只放到入口文件（index.html），需要解决的问题是，同一scope里没有事件的通信，添加到入口的登录框也就接收不到广播的事件。</p>
</li>
</ul>
<p>欢迎参观我的 <a href="https://github.com/o2team/UFT" target="_blank" rel="external">UFT 需求平台</a> 项目。</p>
</div></article></div><div class="payme"><img src="/payme.jpg"></div></section><footer><div class="paginator"><a href="/2016/03/03/Develop-Chrome-Extension/" class="next">NEXT</a></div><div data-thread-key="2016/03/29/Techniques-for-authentication-in-AngularJS-applications/" data-title="【译】AngularJS身份验证技巧" data-url="http://manjiz.com/2016/03/29/Techniques-for-authentication-in-AngularJS-applications/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"manjiz"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://manjiz.com">小振 Manji.z</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>