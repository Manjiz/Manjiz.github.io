<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> “如何稀释scroll事件”引出的问题 · 前端小镇</title><meta name="description" content="“如何稀释scroll事件”引出的问题 - 小振 Manji.z"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"><script src="http://tajs.qq.com/stats?sId=54492646" charset="UTF-8" defer></script></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2289478794" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Manjiz" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">“如何稀释scroll事件”引出的问题</h1><div class="post-info"><span class="post-time">Apr 1, 2016</span><span class="post-author"></span></div><div class="post-content"><p><strong><em>本文原发<a href="http://www.cnblogs.com/xzhang/p/4145697.html" target="_blank" rel="external">博客园</a>（14年12月），博客已迁到这里，原文阅读量671</em></strong></p>
<p>背景：我在segmentfault提了个<a href="https://segmentfault.com/q/1010000000707337?_ea=62905" target="_blank" rel="external">问题</a>如何稀释onscroll事件，问题如下：</p>
<blockquote>
<p>面试时问到这个问题，是这样的：<br>    面试官问一个关于滚动到某个位置的时候出现一个顶部的导航栏，答完之后，她接着问一滚动onscroll就会执行很多很多次，如何稀释它？为了确定她说的是“稀释”，我让她重复了遍，我给出的解决方法是，用一个变量，在事件处理的时候让它自增，判断达到一定大小就执行一次实际的事件：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var i = 0;    // &#32047;&#31215;&#21464;&#37327;&#10;window.onscroll = function()&#123;&#10;    i++;&#10;    if(i%500==0&#65289;&#123;&#10;        // &#25191;&#34892;&#23454;&#38469;&#30340;&#20107;&#20214;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>她并不满意，问最后如何释放这个变量？<br>……<br>接着她说：“我要的是稀释onscroll的执行次数，而不是这个（我所指的实际的事件）的执行次数。”<br>我很是不解，鼠标一滚动就触发这个事件，如何能减少它的执行次数，如何稀释它？难道动态绑定/解绑事件，如何操作？<br>网上都没有找到相关类型的问题，这个问题算不算变态级的面试题？如果不是，请给出解决方案，先谢谢了。</p>
</blockquote>
<p>第一个回答认为这是函数节流，顿时恍然大悟，纳为答案，这是我和该名词的初次接触，本以为就这样结束了，没想到接下来又吸引了一大波程序员的眼球。</p>
<p>基本地，指出使用 throttle 和 debounce 两种方式：</p>
<ul>
<li><strong>throttle</strong>（译：节流阀）：就是函数节流的意思，控制函数调用的频度，固定时间间隔执行，即连续的调用中，不管频度如何，只间隔固定时间（或大于该时间，这时频度较低）执行一次，不是问题中的“稀释”。</li>
<li><p><strong>debounce</strong>（译：防反跳？）：就是去抖的意思，空闲控制，在一定空闲时间间隔内的调用不予实现，一个简单的实现如下：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"mousemove"</span>);</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主要应对高度频发的调用，100的意思不是100ms执行一次，而是当调用间隔时间不超过100ms，即鼠标移动速度过快的话，console.log()会一直不被执行，除非移动间隔时间大于100ms，用网友bumfod的话，「函数节流让一个函数只有在你不断触发后停下来歇会才开始执行，中间你操作得太快它直接无视你。」，不是问题中的“稀释”。</p>
<p>综上，诚然 throttle 和 debounce 都能很好地解决性能问题，<strong>二者稀释的是业务逻辑的执行次数</strong>，但都不是问题所要求的，这时我就觉得这个问题有点牵强了，因为不管怎样，不管有没有显性地定义 scroll 事件，浏览器都会触发 scroll 事件的，差别在于有没有 callback，有没有要执行的东西而已。</p>
<p>如果非要“减少scroll 的执行次数”，这里有一位和我不谋而合的网友代码，通过setTimeout，执行一次再延时重新绑定事件监听器，这种方法<strong>稀释的是回调的执行次数</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cb = &#123;</span><br><span class="line">  onscroll:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"scrolling"</span>);</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">"scroll"</span>, cb.onscroll, <span class="literal">false</span>);   <span class="comment">// 这里移除事件监听器</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"DONE"</span>);</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, cb.onscroll, <span class="literal">false</span>);</span><br><span class="line">    &#125;, <span class="number">200</span>);    <span class="comment">// 200ms后重新绑定事件监听器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, cb.onscroll, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>还有同学引出了阻塞渲染、影响页面UI响应等的问题，</p>
<p><strong>其他：</strong></p>
<p>框架辅助 <a href="http://underscorejs.org/#debounce" target="_blank" rel="external">_debounce</a>（underscore.js 里的 debounce 函数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * [debounce description]</span><br><span class="line"> * @param  &#123;[type]&#125; func      [回调函数]</span><br><span class="line"> * @param  &#123;[type]&#125; wait      [等待时长]</span><br><span class="line"> * @param  &#123;[type]&#125; immediate [是否立即执行]</span><br><span class="line"> * @return &#123;[type]&#125;           [description]</span><br><span class="line"> */</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> last = _.now() - timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于wait时间，继续延迟wait-last执行later，知道last &gt;= wait才执行func</span></span><br><span class="line">        <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            timeout = setTimeout(later, wait - last);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">                result = func.apply(context, args);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        timestamp = _.now();</span><br><span class="line">        <span class="comment">//是否立即执行</span></span><br><span class="line">        <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">            context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">underscore.js 的 debounce</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/twitter/typeahead.js/tree/0fd2467baa3e0593b91794b485be0bd725b7d2cb" target="_blank" rel="external">typeahead</a> 的 throttle 实现源码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">throttle: <span class="function"><span class="keyword">function</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args, timeout, result, previous, later;</span><br><span class="line">    previous = <span class="number">0</span>;</span><br><span class="line">    later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">            remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;   <span class="comment">//如果大于间隔时间（wait）</span></span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            previous = now;</span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout) &#123;  <span class="comment">//小于，延时调用later</span></span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">typeahead.js 的 throttle</span><br></pre></td></tr></table></figure>
<p><strong>摘录原发的评论</strong></p>
<ul>
<li><p>Grart: 根据typeahead的代码再改了个，效果好像没typeahead的好。 - -</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _lazyRun = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _preIndex = <span class="number">0</span>, _nowIndex = <span class="number">1</span>, _timer, _fnCur, _context, _result;</span><br><span class="line">    <span class="keyword">var</span> _fn1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_preIndex &lt; _nowIndex) &#123;</span><br><span class="line">            _fnCur = _fn2;</span><br><span class="line">            clearTimeout(_timer);</span><br><span class="line">            <span class="keyword">var</span> _previous = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            _preIndex = _nowIndex;</span><br><span class="line">            _result = func.apply(_context, _args);</span><br><span class="line">            <span class="keyword">var</span> _remaining = wait - ((<span class="keyword">new</span> <span class="built_in">Date</span>()) - _previous);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (_remaining &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                _result = func.apply(_context, _args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _timer = setTimeout(_fn1, _remaining);<span class="comment">//脱离线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _fnCur = _fn1;</span><br><span class="line">            _preIndex = <span class="number">0</span>, _nowIndex = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> _fn2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        _nowIndex++;</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;;</span><br><span class="line">    _fnCur = _fn1;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        _context = <span class="keyword">this</span>;</span><br><span class="line">        _args = <span class="built_in">arguments</span>;</span><br><span class="line">        _result = _fnCur.apply(_context, _args);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Grart 首先是赞许，自己写，然后，还是觉得原来的代码较好，每次脱离线程，都会进入一次下面那个 else 来重置 _preIndex 和 _nowIndex（似乎是有点多余的步骤），还有，你的_fnCur似乎只用了一次（最后的 return 那里），在其他地方都重新赋值但没用到。</p>
</li>
<li>Grart: _fnCur是函数指针，用来避开判断的。_preIndex 和 _nowIndex是用来做乐观锁比较的，没有事件发生的时候重置，以免数值过大。写了个贴子，不明白看下吧。<br><a href="http://www.cnblogs.com/Grart/p/4148383.html" target="_blank" rel="external">http://www.cnblogs.com/Grart/p/4148383.html</a></li>
<li>hsfzxjy: 还可以用一个变量记录当前处理是否执行完，以此模拟加锁</li>
</ul>
</div></article></div><div class="payme"><img src="/payme.jpg"></div></section><footer><div class="paginator"><a href="/2016/04/01/xplane/" class="next">NEXT</a></div><div data-thread-key="2016/04/01/throttle-and-debounce/" data-title="“如何稀释scroll事件”引出的问题" data-url="http://manjiz.com/2016/04/01/throttle-and-debounce/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"manjiz"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://manjiz.com">小振 Manji.z</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-75781314-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>