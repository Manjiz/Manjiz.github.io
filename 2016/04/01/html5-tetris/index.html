<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 动手打造html5俄罗斯方块 · 前端小镇</title><meta name="description" content="动手打造html5俄罗斯方块 - 小振 Manji.z"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"><script src="http://tajs.qq.com/stats?sId=54492646" charset="UTF-8" defer></script></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2289478794" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Manjiz" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">动手打造html5俄罗斯方块</h1><div class="post-info"><span class="post-time">Apr 1, 2016</span><span class="post-author"></span></div><div class="post-content"><p><strong><em>本文原发<a href="http://www.cnblogs.com/xzhang/p/4097833.html" target="_blank" rel="external">博客园</a>（14年11月），博客已迁到这里，原文阅读量1000</em></strong></p>
<ul>
<li>时间：凌晨2:36</li>
<li>历时：两晚+半个下午</li>
<li>代码：约300行</li>
</ul>
<p>这两天发烧，头痛脑壳昏的，没想到竟然还能有动力去做小游戏，其实这不是我第一次想要弄个俄罗斯方块，前几个星期的时候就尝试着去弄一个，然后被凌乱的代码带进了无尽的深渊，最后忍痛把几天的代码一键删除。这次从头梳理思路，重新设计，结果也正好印证了某人的一句话：有时候重新开始比修bug更省事。</p>
<p>在正文开始之前还要啰嗦一下，标题中所谓自给自足，是在没有参考任何设计思路的前提下去开发这游戏的，你可能会不解，如果参考优秀的思路，岂不是事半功倍，当然，参考与不参考都有利，我只说不参考的利，当我煞费苦心、历经数十个BUG修改，终于完成一件作品的时候，我可以很自豪地对别人说：“看，我开发的游戏！”当然，创意不是我的，但这并不影响自己那份“虚荣心”，为一款经典的游戏赋予自我的理解，并将它融入游戏中，岂不是一件有意思的事，而且，回过头来再看一看别人的思路，有时会拍案而起，“这个我当初怎么就没想到呢？”，“原来这个问题可以这样解决”，“这个设计思路比我的思路好多了！”，诸如此类总比开始就直接看别人的思路而阻塞自己的思考要强得多，对吧？</p>
<p>好叻，正文开始~</p>
<p>想先看效果的，先<a href="http://xzh-loop.github.io/Manji/lab/html5game/20141114-tetris.html" target="_blank" rel="external">跳转</a>试玩一下吧！</p>
<p>俄罗斯方块，主游戏界面应该由一个一个的方块组成，如下图，当然成品里面这些网格是看不到的，这里只是助于理解，主界面尺寸为400×500，设定每块砖（网格）的尺寸为20×20，则每行有20个砖块，每列有25个砖块。相关代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brickWidth = <span class="number">20</span>,    <span class="comment">//砖块大小</span></span><br><span class="line">width = <span class="number">400</span>, height = <span class="number">500</span>;  <span class="comment">//画布宽高，20X25</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2016/160401-1.png" alt=""></p>
<p>提到主界面的网格，就要提到一个非常重要的变量了，它就是BOARD，一个二维数组，形象化地说其尺寸是20×26，存储的值为0或1，0表示该位置没有砖块，1表示该位置有砖块，在接下来的一些判定中有重要作用，游戏细心的同学可能发现，为什么是20×26，而不是对应主界面网格的20×25，我在一开始的时候也是设定为20×25的，后来注意到如果加一行而且这一行的值都为1就可以很容易判断砖块是否到触及主界面底部了。相关代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化BOARD，注意纵向有26个，最后一排用来判断是否触底</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">    BOARD[i] = [];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">25</span>) &#123;</span><br><span class="line">            BOARD[i][j] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BOARD[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2016/160401-2.png" alt=""></p>
<p>接下来看由4个砖块组成的“形状”，有五种，为了好描述，我把它们为别命名，Tian（田），Chu（锄头），Tu（凸起来），Thunder（闪电），Line（一横），哈哈有趣的名字，原谅我没找到它们的英文名字吧。</p>
<p>首先定义一个砖头类Brick：<code>function Brick() { }</code></p>
<p>其下有几个原型变量和方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Brick.prototype.embattle = <span class="literal">null</span>;    <span class="comment">//砖块的布局（需重载）</span></span><br><span class="line">Brick.prototype.isOverturn = <span class="number">0</span>; <span class="comment">//是否翻转</span></span><br><span class="line">Brick.prototype.originX = <span class="number">9</span>;    <span class="comment">//砖头的绘制起点X</span></span><br><span class="line">Brick.prototype.originY = -<span class="number">3</span>;    <span class="comment">//砖头的绘制起点Y</span></span><br><span class="line">Brick.prototype.direction = <span class="number">0</span>;  <span class="comment">//砖头朝向</span></span><br><span class="line">Brick.prototype.autoMoveTimer = <span class="literal">null</span>;   <span class="comment">//自动移动计时器</span></span><br><span class="line">Brick.prototype.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; …… &#125;    <span class="comment">//画砖块的方法</span></span><br><span class="line">Brick.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">moveX, moveY</span>) </span>&#123; …… &#125;    <span class="comment">//移动的方法</span></span><br><span class="line">Brick.prototype.autoMove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; …… &#125;    <span class="comment">//自动移动的方法</span></span><br><span class="line">Brick.prototype.change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; …… &#125;    <span class="comment">//变换砖头朝向</span></span><br></pre></td></tr></table></figure>
<p>Brick的子类有：Tian，Chu，Tu，Thunder，Line五个，每个子类中都重载Brick的embattle变量，embattle是什么，英译中的意思是布阵，这个阵是个什么阵呢？首先，同学们要理解我的思路，用Tu的embattle来举例，其代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.embattle = [</span><br><span class="line">    [ [<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>] ],  <span class="comment">//布局表为4X4表格，数字为砖头位置</span></span><br><span class="line">    [ [<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>] ]   <span class="comment">//次行为翻转的情况</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>embattle是一个三维数组，第一维是是否翻转isOverturn（形象来说就像图片的水平翻转），第二维是方向direction（上左下右），第三维是形状的4个砖块分布情况，我把每个新形状对象定义在一个4×4的阵中，例如，Tu的this.embattle[0][0]为[0,4,5,8]，数字即该砖块的所在位置，如下图：</p>
<p><img src="/images/2016/160401-3.png" alt=""></p>
<p>所以要确定一个形状的位置和样子，需要isOverturn确定是否翻转，需要direction确定其方向，需要originX和originY确定“阵”的位置。</p>
<p>接下来，分别解释Brick的4个原型方法。</p>
<p><strong>Brick.prototype.draw</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">'rgb('</span>+<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>)+<span class="string">','</span>+<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>)+<span class="string">','</span>+<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>)+<span class="string">')'</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">    tmp = <span class="keyword">this</span>.embattle[<span class="keyword">this</span>.isOverturn][<span class="keyword">this</span>.direction][i];</span><br><span class="line">    ctx.fillRect((<span class="keyword">this</span>.originX+tmp%<span class="number">4</span>)*brickWidth, (<span class="keyword">this</span>.originY+<span class="built_in">Math</span>.floor(tmp/<span class="number">4</span>))*brickWidth, brickWidth, brickWidth);</span><br><span class="line">    ctx.strokeRect((<span class="keyword">this</span>.originX+tmp%<span class="number">4</span>)*brickWidth+<span class="number">1</span>, (<span class="keyword">this</span>.originY+<span class="built_in">Math</span>.floor(tmp/<span class="number">4</span>))*brickWidth+<span class="number">1</span>, brickWidth-<span class="number">2</span>, brickWidth-<span class="number">2</span>);   <span class="comment">//注意+1和减2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有上面说的确定形状的位置和样子的方法，之后就是纯粹canvas画图，4个砖块一个一个地画，不要看代码很长其实就是那么一点点，originX、originY和砖块在阵中的位置就可以确定画砖块的起点了。注意到代码的注释了没有，画边框的时候，它是从起点向外面画的，就像我把一个塑料袋套在另一个塑料袋的外面，为了以后的清除的方便且不影响其他的砖块，把边框画进fillRect的领土，就像我现在把这个塑料袋不套在外面而是放进这另一个塑料袋里面一样，就这个意思。</p>
<p><strong>Brick.prototype.move</strong></p>
<p>这是最长的一个了，移动的时候，moveX和moveY表示横纵的增量，没有同时非0的情况（这是人为的设定，要么横向移动要么纵向移动），当然要判断即将移动到的位置是否违规：</p>
<p><strong><em>横向：</em></strong></p>
<p>如果阵贴靠主界面左侧则不能向左移即moveX不能为-1</p>
<p><code>(this.originX==0 &amp;&amp; moveX==-1)</code></p>
<p>判断右边时比较麻烦，因为不能直接用阵来判断是否贴靠右侧（看前面的图就知道阵的右边和下边可能没有砖块的），这时要一个个地判断4个砖块是否有至少有一个在最右，这时不能向右移动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|| (<span class="keyword">this</span>.originX+tmp[<span class="number">0</span>]%<span class="number">4</span>==<span class="number">19</span> &amp;&amp; moveX==<span class="number">1</span>)</span><br><span class="line">|| (<span class="keyword">this</span>.originX+tmp[<span class="number">1</span>]%<span class="number">4</span>==<span class="number">19</span> &amp;&amp; moveX==<span class="number">1</span>)</span><br><span class="line">|| (<span class="keyword">this</span>.originX+tmp[<span class="number">2</span>]%<span class="number">4</span>==<span class="number">19</span> &amp;&amp; moveX==<span class="number">1</span>)</span><br><span class="line">|| (<span class="keyword">this</span>.originX+tmp[<span class="number">3</span>]%<span class="number">4</span>==<span class="number">19</span> &amp;&amp; moveX==<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>最后还要判断即将到达的位置是否已经有砖块了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|| (BOARD[<span class="keyword">this</span>.originX+tmp[<span class="number">0</span>]%<span class="number">4</span>+moveX][<span class="keyword">this</span>.originY+<span class="built_in">Math</span>.floor(tmp[<span class="number">0</span>]/<span class="number">4</span>)]==<span class="number">1</span>)</span><br><span class="line">|| (BOARD[<span class="keyword">this</span>.originX+tmp[<span class="number">1</span>]%<span class="number">4</span>+moveX][<span class="keyword">this</span>.originY+<span class="built_in">Math</span>.floor(tmp[<span class="number">1</span>]/<span class="number">4</span>)]==<span class="number">1</span>)</span><br><span class="line">|| (BOARD[<span class="keyword">this</span>.originX+tmp[<span class="number">2</span>]%<span class="number">4</span>+moveX][<span class="keyword">this</span>.originY+<span class="built_in">Math</span>.floor(tmp[<span class="number">2</span>]/<span class="number">4</span>)]==<span class="number">1</span>)</span><br><span class="line">|| (BOARD[<span class="keyword">this</span>.originX+tmp[<span class="number">3</span>]%<span class="number">4</span>+moveX][<span class="keyword">this</span>.originY+<span class="built_in">Math</span>.floor(tmp[<span class="number">3</span>]/<span class="number">4</span>)]==<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong><em>纵向：</em></strong></p>
<p>即将到达的位置是否已经有砖块了，注意到下面的代码的&amp;&amp; moveX==0，原来是没有的，后来发现每次砖块怎么刚刚靠上下面堆着的砖块就不能再移动了，原来横向移动的时候也进行了这个判断，即刚刚靠上下面的砖块，如果这时想左右移动，但下方有砖块，但是问题来了，下面有没有砖块跟我左右移动有什么关系呢？是吧。</p>
<p><code>if((as==1 || bs==1 || cs==1 || ds==1) &amp;&amp; moveX==0) { …… }</code></p>
<p>纵向终止判断里面主要做了几件事：清除autoMoveTimer，设置BOARD在该形状当前位置的值为1，有可以消除的整行就消除，加分改分，判断胜利/失败，删除当前对象，召唤下一个形状。</p>
<p><strong><em>横纵都没违规时：</em></strong></p>
<p>这时，把该形状前一个位置的砖块清除，更新originX和originY，再画出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">    tmp = <span class="keyword">this</span>.embattle[<span class="keyword">this</span>.isOverturn][<span class="keyword">this</span>.direction][i];</span><br><span class="line">    ctx.clearRect((<span class="keyword">this</span>.originX+tmp%<span class="number">4</span>)*brickWidth, (<span class="keyword">this</span>.originY+<span class="built_in">Math</span>.floor(tmp/<span class="number">4</span>))*brickWidth, brickWidth, brickWidth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.originX += moveX;</span><br><span class="line"><span class="keyword">this</span>.originY += moveY;</span><br><span class="line"><span class="keyword">this</span>.draw();</span><br></pre></td></tr></table></figure>
<p><strong>Brick.prototype.autoMove</strong></p>
<p>只做一件事，设置计时器，定时向下移动。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status, self = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">this</span>.autoMoveTimer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status = self.move(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;,speed);</span><br><span class="line">Brick.prototype.change</span><br></pre></td></tr></table></figure>
<p>改变形状的朝向，很好办啊，不是有embattle数组了吗？当然没有那么简单，不只是换个数组这么简单。要考虑改变方向之后占用的位置是否已经有砖块了，如果形状是贴着主界面右边界就更糟糕了，比如原来是竖着的Line，改变其方向变为横，占用阵的0、1、2、3，如果Line贴着右边界，originX为19，变为横向，占用阵的0、1、2、3，后面三个砖块已经溢出了主界面。</p>
<p><img src="/images/2016/160401-4.png" alt=""></p>
<p>解决方案是：如果有越界的砖块就把阵往左挪一挪，直到不再越界。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ox+tmp[<span class="number">0</span>]%<span class="number">4</span> &gt; <span class="number">19</span> || ox+tmp[<span class="number">1</span>]%<span class="number">4</span> &gt; <span class="number">19</span> || ox+tmp[<span class="number">2</span>]%<span class="number">4</span> &gt; <span class="number">19</span> || ox+tmp[<span class="number">3</span>]%<span class="number">4</span> &gt; <span class="number">19</span>) &#123;</span><br><span class="line">    ox -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，如果都没事，就可以清除原位置，画出改变方向之后的形状了。</p>
<p>并不是太完美，因为有些卡位的情况没考虑进来，什么是卡位，看下图，你知道Line实例调用change方法的结果是什么了吗？事实上，它不应该成功改变方向的，对吧？还有其他一些卡位的情况。</p>
<p><img src="/images/2016/160401-5.png" alt=""></p>
<p>Brick的4个原型方法就介绍到这里了。现在如果我要在右边的信息界面显示下一个的形状，最直接的方法就是，通过该形状的构造函数实例化一个对象，为防止其自动调用autoMove，为构造函数添加了isModel来判断是不是供提示用的。</p>
<p>还有按键事件监听、NextBrick函数和deleteObj自己看看吧，很容易看懂，游戏的入口就是NextBrick函数。</p>
<p>还有就是，我无法确定deleteObj是否真的成功让GC把对象回收了。</p>
<p>还有就是，我本想增加关卡功能，因为可以自由设置速度（speed变量），就把这功能放一放了。</p>
<p>———-20141114更新—</p>
<p>初始化的东西放进一个init函数里了。</p>
<p>还是把关卡功能实现了，速度会越来越快哦，你能挑战多少关呢？←_←</p>
<p><strong>其他：</strong></p>
<p>在线试玩：<a href="http://xzh-loop.github.io/Manji/lab/html5game/20141114-tetris.html" target="_blank" rel="external">http://xzh-loop.github.io/Manji/lab/html5game/20141114-tetris.html</a></p>
<p>访问这个项目的GitHub位置：<a href="https://github.com/xzh-loop/Manji/tree/gh-pages/lab/html5game" target="_blank" rel="external">https://github.com/xzh-loop/Manji/tree/gh-pages/lab/html5game</a></p>
<p>访问我的GitHub主页：<a href="https://github.com/Manjiz" target="_blank" rel="external">https://github.com/Manjiz</a></p>
</div></article></div><div class="payme"><img src="/payme.jpg"></div></section><footer><div class="paginator"><a href="/2016/04/01/xplane/" class="prev">PRVE</a><a href="/2016/03/29/Techniques-for-authentication-in-AngularJS-applications/" class="next">NEXT</a></div><div data-thread-key="2016/04/01/html5-tetris/" data-title="动手打造html5俄罗斯方块" data-url="http://manjiz.com/2016/04/01/html5-tetris/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"manjiz"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://manjiz.com">小振 Manji.z</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-75781314-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>